<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://matteospanio.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://matteospanio.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-26T16:07:55+00:00</updated><id>https://matteospanio.github.io/feed.xml</id><title type="html">blank</title><subtitle>This is a very personal blog. I don&apos;t write blogs for anyone, but just record what I do or what I think. So there are many things wrong and you may have different thoughts. It would be nice if I share knowledge and thoughts rather than criticism. It will be great help if you give and teach your knowledge and thoughts to me. </subtitle><entry><title type="html">Python’s virtual environments</title><link href="https://matteospanio.github.io/blog/2024/python-environments/" rel="alternate" type="text/html" title="Python’s virtual environments"/><published>2024-06-21T00:00:00+00:00</published><updated>2024-06-21T00:00:00+00:00</updated><id>https://matteospanio.github.io/blog/2024/python-environments</id><content type="html" xml:base="https://matteospanio.github.io/blog/2024/python-environments/"><![CDATA[<h1 id="managing-environments">Managing environments</h1> <p>In embarking on projects, I’ve learned the hard way that starting without the right tools can lead to wasted time and frustration. This has been evident in my tendency to recklessly install packages, turning my system’s Python environment into a chaotic mess. Despite the availability of better alternatives, I’ve also stuck with the default Python shell. Investing upfront time and effort to avoid these pitfalls can greatly benefit your journey as a Python enthusiast.</p> <p>While most programming languages provide a standard library with diverse functionalities, managing additional libraries can be challenging. It’s crucial to effectively utilize the standard library, which includes features like file handling, string manipulation, and date/time management. However, to fully leverage Python’s capabilities, additional libraries are often required. Python’s vibrant developer community produces a plethora of third-party packages, allowing for quick and easy installation. Yet, it’s essential to exercise caution and avoid the temptation to install every intriguing package, as it can lead to a chaotic environment where nothing functions properly.</p> <p>With this understanding, let’s delve into pip, the default package manager tool that accompanies Python installation.</p> <h2 id="pip-and-virtual-environments">pip and virtual environments</h2> <p><code class="language-plaintext highlighter-rouge">pip</code> is Python’s package manager. Its name is a recursive acronym that stands for <em>Pip Installs Packages</em>. <code class="language-plaintext highlighter-rouge">pip</code> is a powerful tool that allows you to install, upgrade, and remove additional libraries, and it is included in Python installation starting from version 3.4.</p> <blockquote> <h5 id="legacy-python">Legacy Python</h5> <p class="block-tip">If you are using an older version of Python, you can install pip manually. To do so, simply download the <code class="language-plaintext highlighter-rouge">get-pip.py</code> file from the official Python website at <a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a> and run it with Python.</p> </blockquote> <h3 id="installing-packages">Installing packages</h3> <p>To install a Python package using pip, simply use the install command followed by the name of the package. For example, to install the requests package, which is commonly used for making HTTP requests, you would type:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>requests
</code></pre></div></div> <p>pip will then download and install the <a href="https://docs.python-requests.org/en/latest/index.html">requests package </a> and any dependencies it requires.</p> <p>Now that you have installed requests, you can use it in your Python code by importing it as usual:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">requests</span>

<span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">https://www.example.com</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div> <p>To uninstall a package that you no longer need, you can use the uninstall command followed by the name of the package. For example, to uninstall the requests package, you would type:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip uninstall requests
</code></pre></div></div> <p>As you can see, pip is a simple and straightforward tool for managing Python packages. However, it has one major limitation: it installs packages <strong>globally</strong>, which can lead to conflicts between different projects that require different versions of the same package.</p> <p>To avoid these conflicts, it is best to use <strong>virtual environments</strong>. A virtual environment is an isolated environment that contains its own Python interpreter and its own set of installed packages. This allows you to work on multiple projects with different dependencies without worrying about conflicts. Python provides a built-in module called <a href="https://docs.python.org/3/library/venv.html">venv</a> that allows you to create and manage virtual environments. To create a new virtual environment, you can use the following command:</p> <pre><code class="language-{bash}">python -m venv myenv
</code></pre> <p>This will create a new directory called <code class="language-plaintext highlighter-rouge">myenv</code> that contains a copy of the Python interpreter and a copy of the <code class="language-plaintext highlighter-rouge">pip</code> package manager. Let’s look in detail at the folder structure of the virtual environment with the shell utility <code class="language-plaintext highlighter-rouge">tree</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tree <span class="nt">-L</span> 4 myenv

myenv
├── bin
│   ├── activate
│   ├── activate.csh
│   ├── activate.fish
│   ├── Activate.ps1
│   ├── pip
│   ├── pip3
│   ├── pip3.10
│   ├── python -&gt; python3
│   ├── python3 -&gt; /usr/bin/python3
│   └── python3.10 -&gt; python3
├── include
├── lib
│   └── python3.10
│       └── site-packages
│           ├── _distutils_hack
│           ├── distutils-precedence.pth
│           ├── pip
│           ├── pip-22.0.2.dist-info
│           ├── pkg_resources
│           ├── setuptools
│           └── setuptools-59.6.0.dist-info
├── lib64 -&gt; lib
└── pyvenv.cfg
</code></pre></div></div> <p>As you can see the <code class="language-plaintext highlighter-rouge">bin</code> directory contains the <code class="language-plaintext highlighter-rouge">activate</code> script that allows you to activate the virtual environment. The <code class="language-plaintext highlighter-rouge">lib</code> directory contains the installed packages, and the <code class="language-plaintext highlighter-rouge">include</code> directory contains the header files needed to compile C extensions. The <code class="language-plaintext highlighter-rouge">pyvenv.cfg</code> file contains the configuration of the virtual environment.</p> <p>To activate the virtual environment, you can use the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source </span>myenv/bin/activate
</code></pre></div></div> <p>This will activate the virtual environment, and you will see the name of the virtual environment in your shell prompt.</p> <blockquote> <h5 id="tip">TIP</h5> <p>On Windows, the command to activate the virtual environment is slightly different:</p> <pre><code class="language-{bash}">myenv\Scripts\activate
</code></pre> </blockquote> <p>Once the virtual environment is activated, any packages you install using <code class="language-plaintext highlighter-rouge">pip</code> will be installed in the virtual environment rather than globally. This allows you to work on your project without worrying about conflicts with other projects.</p> <p>For example, to install the requests package in the virtual environment, you would type:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>requests
</code></pre></div></div> <p>but this time the package will be installed in the <code class="language-plaintext highlighter-rouge">myenv</code> directory rather than globally. In fact if you look at the <code class="language-plaintext highlighter-rouge">lib</code> directory of the virtual environment you will see the installed packages:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tree <span class="nt">-L</span> 1 myenv/lib/python3.10/site-packages

myenv/lib/python3.10/site-packages
├── certifi
├── certifi-2024.6.2.dist-info
├── charset_normalizer
├── charset_normalizer-3.3.2.dist-info
├── _distutils_hack
├── distutils-precedence.pth
├── idna
├── idna-3.7.dist-info
├── pip
├── pip-22.0.2.dist-info
├── pkg_resources
├── requests
├── requests-2.32.3.dist-info
├── setuptools
├── setuptools-59.6.0.dist-info
├── urllib3
└── urllib3-2.2.2.dist-info
</code></pre></div></div> <p>When you are finished working on your project, you can deactivate the virtual environment using the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deactivate
</code></pre></div></div> <p>This will return you to the global Python environment.</p> <h3 id="managing-requirements">Managing requirements</h3> <p>When working on a project, it is common to have a list of required packages that need to be installed. This list is often stored in a file called <code class="language-plaintext highlighter-rouge">requirements.txt</code>, which can be used to install all the required packages at once. To create a <code class="language-plaintext highlighter-rouge">requirements.txt</code> file, you can use the following command:</p> <pre><code class="language-{bash}">pip freeze &gt; requirements.txt
</code></pre> <p>This will create a <code class="language-plaintext highlighter-rouge">requirements.txt</code> file that contains a list of all the packages installed in the current environment. To install the packages listed in a <code class="language-plaintext highlighter-rouge">requirements.txt</code> file, you can use the following command:</p> <pre><code class="language-{bash}">pip install -r requirements.txt
</code></pre> <p>This will install all the packages listed in the <code class="language-plaintext highlighter-rouge">requirements.txt</code> file.</p> <h2 id="pipx">pipx</h2> <p>Sometimes, you may want to install a Python application that is not a library, but a standalone program. In this case, you can use <code class="language-plaintext highlighter-rouge">pipx</code>. <code class="language-plaintext highlighter-rouge">pipx</code> is a tool that allows you to install and manage Python applications in an isolated environment. This means that when you install an application with <code class="language-plaintext highlighter-rouge">pipx</code>, it is not installed in the system, but in a dedicated virtual environment. This allows you to avoid conflicts between different versions of libraries and keep your system clean.</p> <pre><code class="language-{bash}">pipx install &lt;package_name&gt;
</code></pre> <p>To uninstall a package installed with <code class="language-plaintext highlighter-rouge">pipx</code>, you can use the following command:</p> <pre><code class="language-{bash}">pipx uninstall &lt;package_name&gt;
</code></pre> <p>It is important to note that <code class="language-plaintext highlighter-rouge">pipx</code> is not a replacement for <code class="language-plaintext highlighter-rouge">pip</code>. It is a complementary tool that is used specifically for installing and managing Python applications. If you want to install a library, you should use <code class="language-plaintext highlighter-rouge">pip</code> instead. <code class="language-plaintext highlighter-rouge">pipx</code> is particularly useful for installing command-line tools that are written in Python, such as <code class="language-plaintext highlighter-rouge">black</code>, <code class="language-plaintext highlighter-rouge">flake8</code>, <code class="language-plaintext highlighter-rouge">isort</code>, and many others that you will likely to use transversally in your projects.</p> <h2 id="conda">conda</h2> <p><code class="language-plaintext highlighter-rouge">conda</code> is an open-source package management system and environment management system that runs on Windows, macOS, and Linux. It is a powerful tool that allows you to create and manage virtual environments, install and update packages, and manage dependencies. <code class="language-plaintext highlighter-rouge">conda</code> is particularly popular in the scientific computing community, as it provides access to a wide range of scientific computing libraries and tools. I suggest to have a look at the official documentation at <a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a> to get started with <code class="language-plaintext highlighter-rouge">conda</code>. An important thing to note is that <code class="language-plaintext highlighter-rouge">conda</code> has its own way to install packages through the <code class="language-plaintext highlighter-rouge">conda install</code> command, which is different from <code class="language-plaintext highlighter-rouge">pip</code>. This is because <code class="language-plaintext highlighter-rouge">conda</code> manages its own package repositories, which are separate from the Python Package Index (PyPI). This means that some packages may be available on <code class="language-plaintext highlighter-rouge">conda</code> but not on PyPI, and vice versa, anyway <code class="language-plaintext highlighter-rouge">conda</code> can install packages from PyPI as well using the <code class="language-plaintext highlighter-rouge">pip</code> package manager.</p> <p><code class="language-plaintext highlighter-rouge">conda</code> solves the virtual environment problem its own way, it lets you create and activate virtual environments creating them for you. When you install <code class="language-plaintext highlighter-rouge">conda</code> for the first time it comes with a default virtual environment called <code class="language-plaintext highlighter-rouge">base</code>. As stated before a good practice is to create a virtual environment for each project, anyway the <code class="language-plaintext highlighter-rouge">conda</code> design encourages you to reuse a virtual environment. For example, you can create a virtual environment called <code class="language-plaintext highlighter-rouge">torch</code> and install the <code class="language-plaintext highlighter-rouge">torch</code> package in it, then you can create another virtual environment called <code class="language-plaintext highlighter-rouge">tensorflow</code> and install the <code class="language-plaintext highlighter-rouge">tensorflow</code> package in it. This way you can switch between the two environments when you need to work on a project that requires <code class="language-plaintext highlighter-rouge">torch</code> or <code class="language-plaintext highlighter-rouge">tensorflow</code>. This is a different approach from <code class="language-plaintext highlighter-rouge">venv</code> where you create a new virtual environment for each project. If you find yourself working on multiple projects that require the same set of packages, <code class="language-plaintext highlighter-rouge">conda</code> can be a good choice for you.</p> <h2 id="poetry--friends">poetry &amp; friends</h2> <p><code class="language-plaintext highlighter-rouge">poetry</code> is a tool for dependency management and packaging in Python. It allows you to declare the libraries your project depends on and it will manage (install/update) them for you. It also allows you to specify the Python version and the Python interpreter to use. <code class="language-plaintext highlighter-rouge">poetry</code> is particularly popular in the data science community, as it provides a simple and powerful way to manage dependencies and package your projects. This tool is really similar to <code class="language-plaintext highlighter-rouge">npm</code> in the JavaScript world, or <code class="language-plaintext highlighter-rouge">cargo</code> in the Rust world, and it is a great way to manage your Python projects. You can find more information about <code class="language-plaintext highlighter-rouge">poetry</code> at <a href="https://python-poetry.org/">https://python-poetry.org/</a>.</p> <p>One of the most interesting features of <code class="language-plaintext highlighter-rouge">poetry</code>, in my opinion, is the fact that you are <em>enforced</em> to organize your project in a specific way. This is because <code class="language-plaintext highlighter-rouge">poetry</code> expects your project to have a specific structure, with a <code class="language-plaintext highlighter-rouge">pyproject.toml</code> file that contains the project’s metadata and dependencies. This makes it easier to manage your project and share it with others, as they will know exactly where to find the project’s dependencies and how to install them.</p> <p><code class="language-plaintext highlighter-rouge">poetry</code> is not the only tool in this category. Other popular tools include <code class="language-plaintext highlighter-rouge">pipenv</code> and <code class="language-plaintext highlighter-rouge">pip-tools</code>. Each of these tools has its own strengths and weaknesses, and the best tool for you will depend on your specific needs and preferences.</p>]]></content><author><name>Matteo Spanio</name></author><category term="Python,"/><category term="Programming"/><category term="python"/><category term="programming"/><category term="code"/><summary type="html"><![CDATA[A brief introduction to Python's virtual environments.]]></summary></entry><entry><title type="html">Python’s Static Typing Safari: In Search of Code Clarity</title><link href="https://matteospanio.github.io/blog/2023/python-static-typing/" rel="alternate" type="text/html" title="Python’s Static Typing Safari: In Search of Code Clarity"/><published>2023-11-10T00:00:00+00:00</published><updated>2023-11-10T00:00:00+00:00</updated><id>https://matteospanio.github.io/blog/2023/python-static-typing</id><content type="html" xml:base="https://matteospanio.github.io/blog/2023/python-static-typing/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>In the vast landscape of programming languages, Python stands out as a dynamically typed language, celebrated for its readability and simplicity. Its syntax, clear and concise, makes it an ideal choice for scripting and automating processes with just a few lines of code. However, as projects grow in complexity and involve multiple contributors, the need for a more robust syntax becomes evident.</p> <p>In this exploration, we dive into the realm of Python’s static typing, unraveling its nuances and unveiling the tools at our disposal. Beyond the simplicity of dynamically typed languages, Python provides features like type annotations, function overloading, and generics, offering developers a sophisticated toolkit for crafting elegant and maintainable code.</p> <p>Let’s embark on a journey through the evolution of a simple addition function, uncovering the power of type annotations, the resurgence of overloading, and the elegance introduced by generics in Python. Join us as we navigate the intricacies of Python’s static typing, discovering how it transforms code clarity and enhances the development experience.</p> <h2 id="bug-alert">Bug alert!</h2> <p>Consider the following lines of code:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span></code></pre></figure> <p>This function sums two elements. In this case, it might seem reasonable to leave it as it is, as you get function overloading for free on types:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">mysum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># a: int, b: int -&gt; int
</span><span class="nf">mysum</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span> <span class="c1"># a: float, b: float -&gt; float
</span><span class="nf">mysum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span> <span class="c1"># a: int, b: float -&gt; float
</span><span class="nf">mysum</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mf">2.3j</span><span class="p">)</span> <span class="c1"># a: int, b: complex -&gt; complex</span></code></pre></figure> <p>All the calls to the <code class="language-plaintext highlighter-rouge">mysum</code> function are correct, and each time Python is able to infer the correct return type. Similarly, these function calls are valid and correct:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">mysum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="nf">mysum</span><span class="p">(</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">)</span></code></pre></figure> <p>However, what happens when you start calling the function with mixed arguments?</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">mysum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">mysum</span><span class="p">({</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nf">mysum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span></code></pre></figure> <p>These lines are legitimate Python, yet most text editors won’t complain. However, once the script executes, the Python interpreter crashes against these type mismatches:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Traceback (most recent call last):
</span><span class="gp">  File "&lt;stdin&gt;</span><span class="s2">", line 1, in &lt;module&gt;
</span><span class="gp">  File "&lt;stdin&gt;</span><span class="s2">"</span>, line 2, <span class="k">in </span>mysum
<span class="go">TypeError: unsupported operand type(s) for +: 'int' and 'NoneType'
</span></code></pre></div></div> <h2 id="type-annotations">Type annotations</h2> <p><code class="language-plaintext highlighter-rouge">TypeError</code>! How is this possible?! Who dared to tell the interpreter to check types? Even though the use of types in Python is mostly transparent, it doesn’t mean they don’t exist. Therefore, annotating types in Python can be a good idea to save hours of debugging. Consider the following:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mysum_number</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">mysum_list</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">mysum_str</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div> <p>Let’s break down the code above. The first function, <code class="language-plaintext highlighter-rouge">mysum_number</code>, accepts two arguments of type <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>, or <code class="language-plaintext highlighter-rouge">complex</code> and returns a value of the same type. The second function, <code class="language-plaintext highlighter-rouge">mysum_list</code>, accepts two arguments of type <code class="language-plaintext highlighter-rouge">list</code> and returns a value of the same type. The third function, <code class="language-plaintext highlighter-rouge">mysum_str</code>, accepts two arguments of type <code class="language-plaintext highlighter-rouge">str</code> and returns a value of the same type.</p> <p>Now, every time you want to add two elements, knowing their type is enough to decide which function to call. However, this precision sacrifices overloading. To call all functions in the same way, indicating the desire for an overload, the standard library <code class="language-plaintext highlighter-rouge">typing</code> contains the <code class="language-plaintext highlighter-rouge">overload</code> decorator. The refactored code looks like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">overload</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
    <span class="bp">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="bp">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="bp">...</span>

<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div> <p>Overloading is back. Now, the function calls seen earlier all work, and those that used to generate a <code class="language-plaintext highlighter-rouge">TypeError</code> at runtime are now highlighted in red by our IDE.</p> <blockquote> <h4 id="note">Note</h4> <p>The three dots <code class="language-plaintext highlighter-rouge">...</code> have a special meaning in Python; it is the symbol known as an <em>ellipsis</em>. This symbol is usually used as a placeholder, but its meaning can vary slightly depending on the context. I recommend checking the documentation if you are curious and want to understand more about it.</p> </blockquote> <h2 id="generics">Generics</h2> <p>We could consider ourselves satisfied like this, but the <code class="language-plaintext highlighter-rouge">typing</code> module offers many other features. Among these, the use of Generics stands out, which in this case can be exploited to create a more elegant solution:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="nc">TypeVar</span><span class="p">(</span><span class="sh">"</span><span class="s">T</span><span class="sh">"</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">TypeVar</code> allows you to define a type that varies depending on the context, but once it is determined, it cannot change:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mysum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1"># T = int
</span><span class="nf">mysum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">)</span>   <span class="c1"># T = float
</span><span class="nf">mysum</span><span class="p">(</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># T = str
</span></code></pre></div></div> <p>Since Python 3.12 the <code class="language-plaintext highlighter-rouge">T</code> typevar declaration can be omitted<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, and the type can be directly specified in the function definition:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mysum</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)](</span><span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div> <blockquote> <h4 id="note-1">Note</h4> <p>Along with <code class="language-plaintext highlighter-rouge">T</code> some constraints have been added, which are the types that <code class="language-plaintext highlighter-rouge">T</code> can assume. In this case, <code class="language-plaintext highlighter-rouge">T</code> can be <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">complex</code>, <code class="language-plaintext highlighter-rouge">str</code>, or <code class="language-plaintext highlighter-rouge">list</code>. That’s because the <code class="language-plaintext highlighter-rouge">+</code> operator is defined for these types and not for others.</p> </blockquote> <h2 id="sum-up">Sum up</h2> <p>In this exploration of Python’s static typing, we delved into crucial concepts that enhance code clarity and maintainability. Let’s recap the key takeaways:</p> <ol> <li> <p><strong>Clear Syntax for All Sizes:</strong> Python’s dynamic typing shines in small scripts, offering a clear and concise syntax. However, as projects grow, the need for a more expressive syntax becomes apparent.</p> </li> <li> <p><strong>Navigating Overloading:</strong> The journey from a dynamically typed function to an overloaded one, thanks to the <code class="language-plaintext highlighter-rouge">typing</code> module’s <code class="language-plaintext highlighter-rouge">overload</code> decorator, showcases Python’s adaptability to diverse project requirements.</p> </li> <li> <p><strong>Type Annotations as Guides:</strong> Embracing type annotations is akin to providing a map for your code. Explicitly specifying types not only aids in debugging but also serves as documentation, making your code more understandable and maintainable.</p> </li> <li> <p><strong>Generics: The Elegance Factor:</strong> The introduction of generics via <code class="language-plaintext highlighter-rouge">TypeVar</code> elevates Python’s static typing to new heights. With constraints on acceptable types, developers can craft more elegant and type-safe solutions.</p> </li> <li> <p><strong>Evolution of Python’s Typing Tools:</strong> From annotations to overloading and generics, Python’s typing tools evolve to cater to various development scenarios, offering a versatile toolkit for developers.</p> </li> </ol> <p>As you navigate your coding endeavors, remember that Python’s static typing is not about rigid constraints but about providing developers with powerful tools to enhance their code’s expressiveness and robustness. Embrace these tools judiciously, and may your coding journey be both clear and elegant.</p> <hr/> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://www.python.org/dev/peps/pep-0695/">PEP 695 – Type Parameter Syntax</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Matteo Spanio</name></author><category term="Python,"/><category term="Programming"/><category term="python"/><category term="programming"/><category term="code"/><summary type="html"><![CDATA[A brief introduction to Python's static typing and its benefits.]]></summary></entry><entry><title type="html">Principles of statistic</title><link href="https://matteospanio.github.io/blog/2022/Principles-of-statistic/" rel="alternate" type="text/html" title="Principles of statistic"/><published>2022-08-30T00:00:00+00:00</published><updated>2022-08-30T00:00:00+00:00</updated><id>https://matteospanio.github.io/blog/2022/Principles-of-statistic</id><content type="html" xml:base="https://matteospanio.github.io/blog/2022/Principles-of-statistic/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Statistic is that field of math which studies collections of empirical data. How are data distributed? Can we infer something from our data?</p> <p>With statistic we can answer to these and other questions.</p> <p>In this article we will discuss about the fundamentals that we need to know before starting an analysis of the data.</p> <hr/> <h2 id="population-samples-parameters-and-statistics">Population samples, parameters and statistics</h2> <p>Data collection is a crucial fact in Statistics. The <em>samples</em> collected and analyzed are used to make scale assertions about the <em>population</em>.</p> <p>It is therefore necessary to divide the types of data we are dealing with in different ways: if a <em>parameter</em> (which is usually a number) concerns a fact of the entire object that is taken into consideration (e.g. the number of women living on earth at a given moment), this is a number that observes the reality of the facts and does not change depending on the observation, it is usually the parameter sought through the statistics, as it is often very difficult or impossible to know these numbers. Statistic takes into account smaller samples of the problem by sampling a part of the population, the quantities are studied on this smaller scale and then they are brought back to a larger scale.</p> <p>Let’s define a glossary with the multiple terms used in statistics that help us to define whether they are absolute numbers related to a certain situation or whether they are related to a studied sample.</p> <h3 id="glossary">Glossary</h3> <ul> <li> <p><strong>Population</strong>: the reality of the facts of which we usually want to know some aspects, if we talk about population we mean to refer to all the units that are part of a certain group;</p> </li> <li> <p><strong>Parameter \(\theta\)</strong>: a characteristic that describes the population (for example the actual mean or median);</p> </li> <li> <p><strong>Census</strong>: observation of <strong>all</strong> population units to quantify a parameter;</p> </li> <li> <p><strong>Sample</strong>: subset of the population used to estimate \(\theta\);</p> </li> <li> <p><strong>Statistics</strong>: any function (or observation) of census or sample data;</p> </li> <li> <p><strong>Estimator</strong>: \(\hat{\theta}\) statistic that is used to reconstruct \(\theta\);</p> </li> <li> <p><strong>Estimate</strong>: value of the estimator on a particular sample.</p> </li> </ul> <h2 id="sampling-and-non-sampling-errors">Sampling and non-sampling errors</h2> <p>The discrepancy between the estimate and the parameter is due to two sources of error:</p> <ol> <li> <p><strong>Sampling errors</strong> unavoidable, they are errors due to the fact that we are observing only a part of the population and they decrease as the sample size increases if the estimator \(\hat{\theta}\) is well constructed;</p> </li> <li> <p><strong>Avoidable non-sampling errors</strong>, they are errors due to a wrong construction of the sample or an incorrect estimator, it is not certain that these errors decrease as the sample size increases.</p> </li> </ol> <hr/> <h2 id="sample-statistics">Sample statistics</h2> <p>Once we have established which entities we are going to focus on, let’s define which statistics are of main interest.</p> <p>Consider a random sample of size \(n\):</p> \[(X_1, ..., X_n)\] <p>the goal is to use the data obtained to reconstruct some parameters of the population. Simple descriptive statistics that measure the location, variability, and other parameters of a given population do not necessarily have to be in the sample already, but estimators and parameter estimates can be derived easily from this sample.</p> <p>The main statistics we use to derive location information are:</p> <ul> <li> <p><strong>sample mean</strong>, to measure the sample mean value;</p> </li> <li> <p><strong>sample median</strong>, to find the central value;</p> </li> <li> <p><strong>quantiles, percentiles, quartiles</strong>, through which the portions of the sample are identified</p> </li> </ul> <p>While the statistics that measure the variability of the data (i.e. how wide the curve is on the graph) are:</p> <ul> <li> <p><strong>sample variance</strong> and <strong>standard deviation</strong></p> </li> <li> <p><strong>interquartile range</strong></p> </li> </ul> <p>Each statistic is a random variable because it is calculated from a sample, which is why they are said to describe the <em>sample distribution</em>.</p> <p>Statistics are used to estimate population parameters, e. g. the ‘sample’ mean is used to estimate the population mean.</p> <p>As for the following sections, always remember that we are considering observations on independent and identically distributed random variables (i.i.d.) with expected value \(E(X) = \mu\) and variance \(Var(X) = \sigma^2\).</p> <h3 id="sample-mean">Sample Mean</h3> <p>The sample mean is a stylist of the population mean \(\mu = E(X)\) and is written:</p> \[\bar {X} = \frac {1}{n} \sum\_{i = 1}^{n} X_i\] <p>therefore \(\bar{x}\) is an estimate of the population value \(\mu\), in fact \(\bar {X}\) is the random variable of the sample mean (i.e. the estimator), while with \(\bar {x}\) we refer to the estimate, that is the number observed with the estimator with a given sample.</p> <blockquote> <p>Summarizing, \(\bar{X}\) is an estimate of \(\mu\), while \(\bar{x}\) is an estimate of \(\mu\).</p> </blockquote> <blockquote> <p>The sample mean has many interesting properties: it is <em>undistorted</em>, <em>consistent</em> and <em>asymptotically Normal</em>.</p> </blockquote>]]></content><author><name>Matteo Spanio</name></author><category term="Statistic"/><category term="statistic"/><category term="math"/><summary type="html"><![CDATA[An introduction to statistic]]></summary></entry><entry><title type="html">DSP: il suono in digitale</title><link href="https://matteospanio.github.io/blog/2021/DSP-il-suono-in-digitale/" rel="alternate" type="text/html" title="DSP: il suono in digitale"/><published>2021-07-10T00:00:00+00:00</published><updated>2021-07-10T00:00:00+00:00</updated><id>https://matteospanio.github.io/blog/2021/DSP-il-suono-in-digitale</id><content type="html" xml:base="https://matteospanio.github.io/blog/2021/DSP-il-suono-in-digitale/"><![CDATA[<blockquote> <p>Dall’analogico al digitale: il digital signal processing spiegato in maniera semplice.</p> </blockquote> <p>Secondo la fisica, il suono è una vibrazione itinerante, cioè un’onda che si muove attraverso un mezzo come l’aria. L’onda sonora trasferisce energia da particella a particella fino a quando non viene finalmente “ricevuta” dalle nostre orecchie e percepita dal nostro cervello. I due parametri fondamentali per descrivere un suono sono l’ampiezza (ciò che chiamiamo anche volume) e l’altezza (o frequenza, la misura delle oscillazioni dell’onda per unità di tempo).</p> <p>La recente crescita tecnologica ha comportato un deciso miglioramento delle performance di velocità e di densità di circuiti e memorie, rendendo possibile la rappresentazione digitale di grandi quantità di dati, compresi i segnali acustici. Nello specifico la digitalizzazione del suono ha comportato una serie di trasformazioni a partire dagli anni ’80, che hanno interessato sia i professionisti che i fruitori di musica. Dall’introduzione sul mercato del primo CD per uso commerciale nel 1982 ad oggi si è assistito alla nascita (e fine) di numerosi supporti digitali (Digital Audio Tape, MiniDisc, USB, DVD, HDD, SSD, Cloud).</p> <p>Ciò ha permesso che il trattamento e il processo numerico dei segnali digitali<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> assumesse una netta preponderanza rispetto a quello analogico: una successione di numeri che rappresentano l’ampiezza del segnale in precisi e ravvicinati istanti di tempo 4 è molto più precisa e affidabile di un’approssimazione non discreta acquisita su un nastro magnetico. Quindi si è dovuto progettare dei sistemi in grado di convertire il suono analogico in una successione di valori che vadano a descrivere i vari parametri del suono (altezza, intensità, timbro). Osservando la rappresentazione cartesiana di un’onda sonora nel dominio del tempo si nota come l’asse delle ordinate descriva l’ampiezza e l’asse delle ascisse metta in evidenza la frequenza a cui si muove l’onda. La conversione del suono da analogico a digitale avviene quindi sui due livelli suddetti: si parlerà di campionamento per la frequenza e quantizzazione per l’ampiezza.</p> <div class="mt-3 mt-md-0"> <img src="assets/img/47.png" class="img-fluid rounded z-depth-1" data-zoomable="true"/> </div> <div class="caption"> a) segnale analogico, b) quantizzato, c) campionato, d) quantizzato e campionato </div> <h2 id="campionamento">Campionamento</h2> <p>Il campionamento corrisponde all’individuazione periodica della presenza di segnale da parte della macchina e consente di analizzare e ricostruire le frequenze in ingresso.</p> <h2 id="quantizzazione">Quantizzazione</h2> <p>La quantizzazione è il processo di sostituzione di ogni numero reale della sequenza di campioni con un’approssimazione da un insieme finito di valori (solitamente \(2^{16}\))</p> <h2 id="la-trasformata-di-fourier">La trasformata di Fourier</h2> <div class="mt-3 mt-md-0"> <img src="assets/img/ft.gif" class="img-fluid rounded z-depth-1" data-zoomable="false"/> </div> <p>Oltre alla rappresentazione del suono nel dominio del tempo, esiste la possibilità di rappresentarne le stesse proprietà anche nel dominio della frequenza. Questo sistema venne studiato da Charles Fourier, che definì anche come passare dalla rappresentazione nel dominio del tempo a quello nel dominio della frequenza, questo processo è detto <em>trasformata di Fourier</em> o <em>Fourier Transform</em> (FT).</p> <p>Quando il segnale di partenza è in formato digitale si può applicare la <em>Trasformata Discreta di Fourier</em> (DFT). L’idea sottostante alla DFT è che lo spettro sia campionato in frequenza così come la forma d’onda digitale viene campionata nel tempo.</p> <div class="mt-3 mt-md-0"> <img src="assets/img/ft2.gif" class="img-fluid rounded z-depth-1" data-zoomable="false"/> </div> <p>Matematicamente parlando, la relazione tra \(N\) campioni nel dominio del tempo \(x*0, x_1, ..., x*{N-1}\) e \(N\) numeri complessi della trasformata discreta di Fourier \(X*0, X_1, ..., X*{N-1}\) è descritta dalla formula:</p> \[X*k = \sum*{n = 0}^{N-1} x_ne^{-ik\frac{2\pi}{N}n}\quad k=0,..., N-1\] <p>dove $ i $ è l’unità immaginaria e \(e^\frac{2\pi}{N}\) è una radice dell’unità primitiva \(N\)-esima.</p> <h2 id="pulse-code-modulation">Pulse Code Modulation</h2> <p>Il passo finale della digitalizzazione, che ingloba i processi di quantizzazione e campionamento, è la generazione del codice associato al campione.</p> <p>Esistono molti modi di codificare un segnale. Il modo di cui ci siamo concettualmente serviti senza saperlo è il <em>Pulse Amplitude Modulation</em> (PAM), per il quale un impulso occorre a ogni intervallo di campionamento, e l’ampiezza della forma d’onda è un valore digitale che corrisponde all’ampiezza analogica. Ma il modello considerato standard per la codifica digitale è il cosiddetto <em>Pulse Code Modulation</em> (PCM): l’informarmazione viene racchiusa in gruppi di bit che rappresentano il variare dell’ampiezza nel tempo, l’uno corrsiponde a presenza di segnale, mentro lo 0 ne descrive l’assenza.</p> <p>La codifica PCM è usata in tutti i settori dell’archiviazione e della trasmissione digitale dei dati. La comodità di questa rappresentazione è che si possono facilmente operare controlli o modifiche sui bit senza perdere il segnale originale, inoltre è molto meno sensibile al rumore delle altre codificazioni.</p> <div class="mt-3 mt-md-0"> <img src="assets/img/62.png" class="img-fluid rounded z-depth-1" data-zoomable="true"/> </div> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>DSP sta per <em>Digital Signal Processing</em> ed e’ un termine usato per indicare l’elaborazione elettrica dei segnali, permettendo al computer di analizzarli. Questo tipo di operazioni sta alla base di molti campi di applicazione: dal sound engineering alle telecomunicazioni, passando per la computer vision. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Matteo Spanio</name></author><category term="DSP"/><category term="music"/><category term="DSP"/><summary type="html"><![CDATA[Dall’analogico al digitale: il digital signal processing spiegato in maniera semplice.]]></summary></entry></feed>